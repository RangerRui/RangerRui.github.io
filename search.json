[{"title":"Java基础","url":"/2022/04/27/Java基础知识/","content":"\n\n\nJava基础知识分享\n\n<!-- more -->\n\n# Java基础\n\n## 1、Java和C++的不同\n\n### 1.1、String的不同\n\n在c++中，string字符串是可以修改的，并可以通过[ ]来直接访问。\n\n在Java中，String对象内部是public final char[]的（现在应该是public final byte[]的），所以不可修改，它的众多api都是返回一个新的String对象。并且它其中的String不可以用[]来直接访问，需要用s.charAt()来访问（下标与c++中[]访问一致）。\n\n### 1.2、HashMap的不同\n\n在c++中，hashmap<int,int>初始化后，可以访问任何整形做key的值，都为0。\n\n但是Java中，hashmap<int,int>初始化后，如果访问不存在的key，那只会返回null。可以通过map.getOrDefault(num,0)，即访问值，如果不存在就返回后面一个设置的默认值。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 2、Java面向对象\n\n## 3、反射\n\n## 4、注解\n\n## 5、泛型\n\n## 6、集合\n\n## 7、Java的I/O\n\n### 7.1、File对象\n\nJava.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。\n\nJava.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。\n\n一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。\n\n**File对象**可以用来操作文件或者目录，构造File对象时，既可以传入绝对路径，也可以传入相对路径。\n\n```\npublic static void main(String[] args) {\n    File f = new File(\"C:\\\\Windows\\\\notepad.exe\");\n    System.out.println(f);\n}\n```\n\n这段代码相当于只创建了个对象，什么都没做。\n\n<img src=\"D:\\笔记\\Typora\\Tpora笔记\\图片\\创建file对象.png\" alt=\"创建file对象\" style=\"zoom:80%;\" />\n\n使用File创建一个文件（需要使用try/catch块环绕，因为有可能创建失败报错IOException）：\n\n```\npublic static void main(String[] args) {\n    File f = new File(\"C:\\\\Windows\\\\notepad.exe\");\n    try {\n            f.createNewFile();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n}\n```\n\n**File对象**既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使**传入的文件或目录不存在，代码也不会出错**，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。\n\n**Path对象**则可以用来操作目录。\n\n### 7.2、InputStream\n\nInputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。\n\n要特别注意的一点是，InputStream并不是一个接口，而是一个**抽象类**，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是**int read()**。\n\n这个方法会读取输入流的下一个字节，并返回**字节表示的int值（0~255）**。如果已读到末尾，返回-1表示不能继续读取了。\n\n**一个一个字节地读取：**\n\n```\npublic void readFile() throws IOException {\n    InputStream input = null;\n    try {\n        input = new FileInputStream(\"src/readme.txt\");\n        int n;\n        while ((n = input.read()) != -1) { // 利用while同时读取并判断\n            System.out.println(n);\n        }\n    } finally {\n        if (input != null) { input.close(); }\n    }\n```\n\n**缓冲方法读取（一次性读取多个字节到缓冲区）：**\n\n```\npublic void readFile() throws IOException {\n    try (InputStream input = new FileInputStream(\"src/readme.txt\")) {\n        // 定义1000个字节大小的缓冲区:\n        byte[] buffer = new byte[1000];\n        int n;\n        while ((n = input.read(buffer)) != -1) { // 读取到缓冲区\n            System.out.println(\"read \" + n + \" bytes.\");\n        }\n    }\n}\n```\n\n**真正的把文件中的信息读出来，转化为一个String：**\n\n```\npublic static void main(String[] args) throws IOException {\n        String s;\n        try (InputStream input = new FileInputStream(\"D:\\\\test.txt\")) {\n            int n;\n            StringBuilder sb = new StringBuilder();\n            while ((n = input.read()) != -1) {\n                sb.append((char) n);\n            }\n            s = sb.toString();\n        }\n        System.out.println(s);\n    }\n```\n\n### 7.3、OutputStream\n\n用于在文件中写入数据。\n"},{"title":"算法","url":"/2022/04/27/算法/","content":"\n\n\n常见算法以及算法题分享\n\n<!-- more -->\n\n# 栈/队列\n\n## 1、两个栈实现队列\n\n设置一个栈left，一个栈right，入队操作直接压入left栈即可。\n\n出队操作：\n\n如果right栈为空，需要把left栈的所有元素出栈，并压入right栈，然后right执行出栈操作一次。\n\n如果right栈不为空，直接对其执行出栈操作即可。\n\n## 2、实现栈的min函数\n\n设置一个栈stk和一个辅助栈sup，入栈时：\n\n- stk为空，两个栈一起压入该元素。\n- stk不为空，如果压入的元素小于等于sup栈的栈顶，stk入栈，辅助栈也入栈，反之辅助栈不入栈。\n\n出栈时：\n\n- 如果出栈的元素等于辅助栈栈顶，那么辅助栈也出栈。\n- 否则直接出栈。\n\n**刁难面试题：只使用一个栈怎样去做这道题？**\n\n为一个栈设置一个变量min_num，表示此时栈中的最小值，而栈中存取的值表示它与它存储之前的min_num的差值。\n\n```c++\n\tstack<long> stk;\n    long min_num;\t\t//long型是为了防止溢出，有可能上一个值是int_min，下一个是int_max\n    MinStack() {\n    }\n    \n    void push(int x) {\n        if(stk.empty()){\n            min_num = x;\n            stk.push(0);\n        }\n        else{\n            long tmp = x;\n            tmp = tmp-min_num;\n            stk.push(tmp);\n            if(tmp<0)min_num+=tmp;\n        }\n    }\n    \n    void pop() {\n        if(stk.top()<0){\n            min_num-=stk.top();\n        }\n        stk.pop();\n    }\n    \n    int top() {\n        if(stk.top()<0)return min_num;\n        return stk.top()+min_num;\n    }\n    \n    int min() {\n        return (int)min_num;\n    }\n```\n\n## 3、字符串解码\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n思路：使用辅助栈，详情见代码注释。\n\n```java\npublic String decodeString(String s) {\n        //一个用来存放数字的栈，一个用来存放字符串的栈  \n        Stack<Integer> stack_num = new Stack<>();\n        Stack<String> stack_res = new Stack<>();\n        //记录即时的数量\n        int num = 0;\n        StringBuilder res = new StringBuilder();\n        for(Character c : s.toCharArray()){\n            //碰到[，把当前的res和num都存进对应的栈，然后把这两个变量都重新初始化\n            if(c=='['){\n                stack_num.push(num);\n                stack_res.push(res.toString());\n                num = 0;\n                res = new StringBuilder();\n            }\n            //碰到]，把栈中num取出来，然后让tmp变成num*res(num>0)，然后把栈中对应的字符串取出拼接上\n            else if(c==']'){\n                StringBuilder tmp = new StringBuilder();\n                int cur_num = stack_num.pop();\n                for(int i = 0; i < cur_num; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.pop()+tmp);\n            }\n            //是数字继续增加当前的num值\n            else if(c >= '0' && c <= '9') num = num * 10 + c - '0';\n            else res.append(c);\n        }\n        return res.toString();\n    }\n```\n\n\n\n# 排序\n\n## 1、根据身高重建队列\n\n假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\n\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\n\n**就是说给一个属性数组，每个元素也是一个数组，数组的第一位表示该人的身高，第二位表示他前面应该有几个大于或者等与他身高的人，然后把他按照要求排好队。**\n\n关键：\n\n我们先按照身高从大到小排序（身高相同的情况下K小的在前面），这样的话，无论哪个人的身高都小于等于他前面人的身高。所以接下来只要按照K值将他插入相应的位置就可以了。\n例如：示例1排完序：[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]\n\n新建一个二维vector：\n[7,0]插入第0的位置\n[7,1]插入第1的位置\n[6,1]插入第1的位置，这时[7,1]就往后移一位（但对于[7,1]并没有影响，因为[6,1]比他矮，不会影响ki值）\n\n```java\npublic int[][] reconstructQueue(int[][] people) {\n       Arrays.sort(\n            people, new Comparator<int[]>() {\n                public int compare(int[] person1, int[] person2) {\n                    if (person1[0] != person2[0]) {\n                        //前面减后面从小到大，后面减前面从大到小\n                        return person2[0] - person1[0];\n                    } else {\n                        return person1[1] - person2[1];\n                    }\n                }\n            }\n        );\n        List<int[]> list = new LinkedList<>();\n        //第一个元素入数组\n        list.add(people[0]);\n        for(int i=1;i<people.length;i++){\n            list.add(people[i][1],people[i]);\n        }  \n        return list.toArray(new int[list.size()][]);\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 动态规划\n\n## 1、除自身以外数组的乘积\n\n***给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。***\n\n***题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。***\n\n***请不要使用除法，且在 O(n) 时间复杂度内完成此题。***\n\n思路：上三角与下三角\n\n举例：给定数组为[1,2,3,4]\n\n| 原数组       | 1          | 2       | 3       | 4          |\n| ------------ | ---------- | ------- | ------- | ---------- |\n| 左部分的乘积 | 1          | 1       | 1*2     | 1* 2 *3    |\n| 右部分的乘积 | 2* 3*4     | 3*4     | 4       | 1          |\n| 结果         | 1* 2* 3 *4 | 1* 3 *4 | 1* 2* 4 | 1* 2* 3 *1 |\n\n就是左边乘积乘右边乘积，动态规划先得到左乘积和右乘积的数组，然后遍历相乘即可。\n\n\n\n## 2、完全平方数\n\n给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。\n\n**完全平方数**是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n**关键思路：**\n\n类似完全背包，动态规划，dp[n]表示和为n的完全平方数最小数量，举例：\n\n| 上一个 | 加的平方数 | dp[11] |\n| ------ | ---------- | ------ |\n| dp[2]  | 9          |        |\n| dp[7]  | 4          |        |\n| dp[10] | 1          |        |\n\n所以dp[11]的值就是其减一个完全平方数的dp值中最小的一个，再加上一（加上一个完全平方数）。\n\n```c++\n    int numSquares(int n) {\n        vector<int> dp(n+1);\n        for(int i=1;i<=n;i++){\n            int minn = i;            //最坏情况有多少个1,如三含3各一。\n            for(int j=1;j*j<=i;j++){\n                minn = min(minn,dp[i-j*j]);\n            }\n            dp[i] = minn + 1;\n        }     \n        return dp[n];\n    }\n```\n\n\n\n## 3、最长递增子序列\n\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n\n子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n\n（1）**思路一：**\n\ndp[i]表示为以第i位数字结尾的递增子序列最长长度，所以从左边第1位向右遍历，如果左边的数小于nums[i]，那么dp[i]可以选择成为一个子序列（第j位的下一位就是第i位）：即dp[j]+1。\n\n也可以选择不动：即dp[i]（比如1 2 3 4 5 2 7），虽然7左边的2比它小，但是如果递增子序列变为2 7，反而比1 2 3 4 5 7变短了。\n\n```c++\nint lengthOfLIS(vector<int>& nums) {\n        int len = nums.size();\n        if(len==0)return 0;\n        int res=0;\n        vector<int> dp(len,1);\n        for(int i=0;i<len;i++){\n            for(int j=0;j<i;j++){\n                if(nums[j]<nums[i])dp[i] = max(dp[j]+1,dp[i]);           \n            }\n            res = max(res,dp[i]);\n        }\n        return res;\n    }\n```\n\n（2）**思路二：**\n\n贪心+二分法，我们维护一个长度为i+1的数组tail，dp[i]表示该长度下可以做结尾的最小数。比如1 2 3 4 5 6，长度为3的递增子序列有1 2 3，2 3 4等等，但是结尾最小的是3。（该数组并不是最长递增子序列）\n\n然后我们证明该数组是单调递增的：\n\n<img src=\"D:\\笔记\\Typora\\Tpora笔记\\图片\\算法\\最长递增子序列单调证明.png\" alt=\"最长递增子序列单调证明\" style=\"zoom:67%;\" />\n\n**然后不断遍历数组，分两种情况即可：**\n\n- 数组的该位大于tail数组的尾元素，直接加进去即可。\n- 小于等于，找到数组第一个比它大/等于的数，替换即可\n\n```c++\nint lengthOfLIS(vector<int>& nums) {\n        int len = nums.size();\n        if(len<2)return len;\n        int res=0;\n        vector<int> tail;\n        tail.push_back(nums[0]);\n        //tail数组的尾部索引\n        int end = 0;\n        for(int i=1;i<len;i++){\n            if(tail[end]<nums[i]){\n                tail.push_back(nums[i]);\n                end++;\n            }\n            else{\n                int left = 0,right = end;           \n                while(left<right){\n                    int mid = left + ((right-left)>>1);\n                    if( tail[mid]<nums[i])left=mid+1;\n                    else right=mid;     //为什么不是mid-1？因为不一定有相同的，那就找到那个恰好比它大的\n                }\n                tail[left] = nums[i];    \n            }     \n        }\n        return end+1;\n    }\n```\n\n## 4、最佳买卖股票时机含冷冻期\n\n给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n代码有详细注释：\n\n```c++\nint maxProfit(vector<int>& prices) {\n        int res=0;\n        int n = prices.size();\n        if(n<2)return res;\n        //每天需要分两种情况，持有和不持有dp1 dp2\n        vector<int> dp1(n,0);\n        vector<int> dp2(n,0);\n\n        //持有一个更低价的股票\n        dp1[0] = -prices[0];\n        dp1[1] = max(dp1[0], -prices[1]);\n        //第二天的股价比第一天高就卖\n        dp2[1] = max(prices[1]-prices[0],0);\n\n        for(int i=2;i<n;i++){\n            //持有分两种情况：昨天持有，今天依旧持有：dp1[i-1]。前天不持有，今天买了持有（防止冷冻期）：dp2[i-1]-prices[i]\n            dp1[i] = max(dp1[i-1],dp2[i-2]-prices[i]);\n            //不持有也分两种情况：昨天不持有，今天依旧不持有：dp2[i-1]。昨天持有，今天卖出：dp1[i-1]+prices[i])。\n            dp2[i] = max(dp2[i-1],dp1[i-1]+prices[i]);\n        }\n        return max(dp1[n-1],dp2[n-1]);\n    }\n```\n\n## 5、分割等和子集\n\n给你一个 **只包含正整数** 的 **非空** 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n思路：动态规划，就是看是否可以从输入数组中挑选出一些正整数，使得这些数的和 等于 整个数组元素的和的一半。\n\n```java\npublic boolean canPartition(int[] nums) {\n        //看能否从数组中挑选出元素，使得他们的和为数组元素总和的一半\n        int len = nums.length;\n        //元素少于两个，肯定不能分割成功\n        if(len<2)return false;\n        int sum = 0,maxnum=0;\n        for(int x:nums){\n            sum+=x;\n            if(x>maxnum)maxnum=x;\n        }\n        //元素总和不能被2整除或者总和的一半小于最大的数，也不行\n        if(sum%2==1||sum/2<maxnum)return false;\n        int target = sum/2;\n        //dp，表示从0到i位选若干个数能否刚好为target\n        boolean[][] dp= new boolean[len][target+1]; \n        //初始化，dp[][0]肯定都为true（都不选）\n        for(int i=0;i<len;i++){\n            dp[i][0] = true;\n        }\n        //初始化，dp[i][nums[i]]肯定为true，只选自己\n        for(int i=0;i<len;i++){\n            dp[i][nums[i]] = true;\n        }\n\n        for(int i=1;i<len;i++){\n            for(int j=target;j>=0;j--){\n                if(j>=nums[i]&&dp[i-1][j-nums[i]]) dp[i][j] = dp[i-1][j-nums[i]];       //选择该位数字\n                else dp[i][j] = dp[i-1][j];                                             //不选择该位数字     \n            }\n        }\n        return dp[len-1][target];\n    }\n```\n\n可以对空间复杂度进行一下优化（就是背包问题空间复杂度的优化），即因为下一个i判断用到的dp中的j都是<=当前的，所以只用一个数组，但是遍历j循环的时候，要注意反着来（正着来会刷新掉后续要用的dp[j]值）。\n\n# 二叉树\n\n\n\n\n\n\n\n\n\n## 5、寻找二叉树的最近公共祖先\n\n***给定一个二叉树，找到该树中两个指定节点的最近公共祖先。***（一定存在，并且二叉树中个节点值各不相同）\n\n**思路**：他们的公共祖先只有两种情况：\n\n- 是两个节点中的一个。\n- 两个节点分列他的左右子树中，那么我们直接返回该节点即可。\n\n我们采用递归的方法，递归左右子树，如果一边为null那么肯定另一边返回的就是他们的最近公共祖先。\n\n```c++\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root==nullptr||root==p||root==q)return root;\n        TreeNode* left = lowestCommonAncestor(root->left,p,q);\n        TreeNode* right = lowestCommonAncestor(root->right,p,q);\n        if(left==nullptr&&right==nullptr)return nullptr;\n        if(left==nullptr)return right;\n        if(right==nullptr)return left;\n        return root;\n    }\n};\n```\n\n## 6、零钱兑换\n\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n\n你可以认为每种硬币的数量是无限的\n\n\n\n思路：dp的长度是给定总金额的大小，每次遍历一遍数组看能否有硬币金额组成该总金额，事先初始化dp的每个元素大小金额+1（表示该总金额无法选择硬币凑出）。\n\n```c++\n int coinChange(vector<int>& coins, int amount) {\n        int len = coins.size();\n        vector<int> dp(amount+1,amount+1);\n        dp[0] = 0;     \n        for(int i=1;i<=amount;i++){\n            for(int j=0;j<len;j++){\n                if(coins[j]<=i){\n                    dp[i] = min(dp[i],dp[i-coins[j]]+1);\n                }\n                \n            }\n        }\n        return dp[amount]>amount?-1:dp[amount];\n    }\n```\n\n## 7、打家劫舍Ⅲ\n\n小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。\n\n除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。\n\n给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 \n\n**思路：**\n\n我们可以用 g(o)表示选择本节点的情况下，节点的子树上被选择的节点的最大权值和。f(o)表示不选择本节点的情况下，节点的子树上被选择的节点的最大权值和。\n\n- 选择本节点，那本节点的左右子节点就都不能选择。\n- 不选择本节点，那左右子节点就可以被选择和不被选择，取他们中最大的即可。\n\n```c++\nunordered_map<TreeNode*,int> f;\nunordered_map<TreeNode*,int> g;\n    void dfs(TreeNode* root){\n        if(root==nullptr)return;\n        dfs(root->left);\n        dfs(root->right);\n        g[root] = f[root->left]+f[root->right]+root->val;\n        f[root] = max(f[root->left],g[root->left]) + max(f[root->right],g[root->right]);\n    }\n\n    int rob(TreeNode* root) {\n        dfs(root);\n        return max(g[root],f[root]);\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 链表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# DFS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 双指针\n\n\n\n## 1、交换0\n\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n\n（1）思路一：双指针，左指针左边维护已满足题意的部分，右指针不断递增，如果右指针指向的数非0，就将左指针指向的数与其交换，并将左指针右移一位。\n\n其实就是类似于冒泡，把0浮上去。\n\n```c++\nvoid moveZeroes(vector<int>& nums) {\n        int left=0,right=0;\n        int n = nums.size();\n        while(right<n){\n            if(nums[right]!=0){\n                swap(nums[left],nums[right]);\n                left++;\n            }\n            right++;\n        }\n    }\n```\n\n（2）思路二：从左开始按数组中的非0值依次覆盖，覆盖完右边的全部为0即可。\n\n\n\n\n\n\n\n\n\n\n\n# 滑动数组\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 原地修改\n\n## 1、寻找重复数\n\n给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。\n\n假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。\n\n你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。\n\n\n\n把它们按位置排好，nums[0] = 1，nums[1] = 2 ......\n\n```c++\nint findDuplicate(vector<int>& nums) {\n        int len = nums.size();\n        //只要不是自己跟自己换，那么要换过去的位置已经有自己这个数，直接返回\n        for(int i=0;i<len;i++){\n            if(nums[i]!=i+1)\n            {\n                if(nums[nums[i]-1]==nums[i])return nums[i];\n                swap(nums[nums[i]-1],nums[i]);\n                if(nums[i]!=i+1)i--;\t\t//只要交换过来的数不是本位该有的，继续交换\n            }\n        }\n        return 0;\n    }\n```\n\n\n\n# 余数问题\n\n## 1、01字符串\n\n给定一串只由01组成的字符串，判断该数能有多少个字串能整数k。\n\n```c++\n//取余多个数的方法\nint rmod(vector<int> a,int k){ //求模的函数\n    int r=0;\n    for(auto &x:a){\n        r=r*10+x;\n        r%=k;\n    }\n    return r;\n}\n\nvoid solution(){\n    cin>>n>>k>>str;\n    int res=0;\n    vector<int> a;\n    unordered_map<int,int> mp;\n    mp[0]++;\n    for(int i=0;i<n;i++){\n        a.push_back(str[i]-'0');\n        int r=rmod(a,k);\n        if(mp.count(r)) res+=mp[r];\n        mp[r]++;\n    }\n    cout<<res<<endl;\n}\n\n首先，明确一点，如果 a % k = r,b % k = r, 那么(a - b) % k = 0。\n算法：i指针遍历字符串s,s[0, i] % k = r,如果在i之前出现了相同的余数r，就累加map[r],然后更新map[r]。\n```\n\n\n\n\n\n\n\n\n\n# 位运算\n\n**求某数二进制表达形式中1的个数：**\n\n利用 **Brian Kernighan** 算法，可以在一定程度上进一步提升计算速度。{Brian Kernighan}Brian Kernighan 算法的原理是：对于任意整数 x，令 x=x&(x-1)，该运算将 xx 的二进制表示的最后一个 1 变成 0。因此，对 x 重复该操作，直到 x 变成 0，则操作次数即为 x 的「一比特数」（二进制表示中1的个数）。\n\n**求某数是否是2的整数次幂：**\n\n看i&(i-1)是否等于0\n\n## 1、比特位计数\n\n给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。\n\n**思路：**如果存在  0≤j<i，j 的「一比特数」已知，且 i 和 j 相比，i 的二进制表示只多了一个 1，则可以快速得到 i 的「一比特数」。\n\n令 bits[i] 表示 i 的「一比特数」，则上述关系可以表示成：bits[i]=bits[j]+1。\n\n用一个数**highbit**来维护当前数二进制形式的最高位大小，i&(i-1)=0，说明该数是二进制的证书次幂，更新最高位，当前数二进制形式下1的个数就为减去最高位1之后的个数+1.\n\n```c++\nvector<int> countBits(int n) {\n        vector<int> bits(n+1);\n        int highbit=0;\n        for(int i=1;i<=n;i++){\n            if((i&(i-1))==0)highbit=i;\n            bits[i] = bits[i-highbit]+1;\n        }\n        \n        return bits;\n    }\n```\n\n# 优先队列\n\n## 1、前K个高频元素\n\n给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n\n```java\npublic int[] topKFrequent(int[] nums, int k) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n\n        //int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n    \t//Java中优先队列默认是最小优先队列，最大优先队列需要重写Comparator函数（o1-o2是最小优先队列，o2-01是最大优先队列）\n         PriorityQueue<int[]> queue = new PriorityQueue<int[]>(\n             new Comparator<int[]>() {\n            \tpublic int compare(int[] m, int[] n) {\n                \treturn m[1] - n[1];\n            \t}\n        \t}\n         );\n\n        for(Map.Entry<Integer,Integer> entry:map.entrySet()){\n            int num = entry.getKey(),count = entry.getValue();\n            if(queue.size()==k){\n                if(queue.peek()[1]<count){\t\t\t\t\t//peek返回队列头\n                    queue.poll();\t\t\t\t\t\t\t//移除队列头\n                    queue.offer(new int[]{num,count});\t\t//向该队列插入元素\n                }\n            }else{\n                queue.offer(new int[]{num,count});\t\t\t//向该元素插入元素\n            }\n        }\n        int[] ret = new int[k];\n        for(int i=0;i<k;i++){\n            ret[i] = queue.poll()[0];\t\t\t\t\t\t\t\n        }\n        return ret;\n    }\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"TCP的拥塞控制","url":"/2022/04/24/计算机网络/","content":"\n\n常见计算机网络相关知识以及面经\n\n<!-- more -->\n\n**超时重传机制**\n\n超时重传机制主要是为了解决数据包在传输过程中丢失的问题。\n\nTCP每发送一个报文段，就会为这个报文段开启一个定时器，如果定时器溢出时仍然没有收到接收端的应答报文，那么TCP就认为这个报文段在传输过程中丢失，然后重新发送这个报文段。这便是超时重传机制\n\n举例：客户端请求发送”and hi”报文段时启动了定时器，然而在规定的时间内没有收到对端的回复，所以重新发送”and hi”报文段，并重启定时器(重启的定时器时间会增大)。\n\n**拥塞控制：**\n\n超时重传是为了解决数据丢失的问题，而数据丢失的原因很大程序上是由于传输路径拥塞导致的。\n\n在正常的传输过程中，数据是从一个路由器跳到下一个路由器，每个路由器都有自己的缓冲区，新来的数据会存放在缓冲区中，与此同时路由器也在不断地将缓冲区中的数据发送给下一个路由器。但是如果某个路由器接收数据的速率大于发送数据的速率，就会导致缓冲区数据累积，最终填满缓冲区。此时如果再有数据到来，缓冲区已经无法容纳它们，只能将它们丢掉，造成数据丢失，这就是所谓的拥塞现象，本质就是传输路径上的节点不平衡。为了解决这一问题，就需要当出现拥塞现象时立即减少发送端发送的数据量，为路径上的某些节点提供清空缓冲区的时间，同时也避免了不必要的重传。\n\n但是，发送端如何才能得知网络中发生了拥塞呢。因为由于硬件错误造成的数据丢失是很罕见的，所以发送端假定，如果出现了数据丢失，那么就可以认定发生了拥塞。\n\n发送方维持一个叫做**拥塞窗口cwnd（congestion window）**的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，**发送窗口等于拥塞窗口和接收窗口中的最小值**。\n\n**四个传输过程中的算法：**\n\n（1）慢开始\n\n慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。\n\n这里用报文段的个数的拥塞窗口大小举例说明慢开始算法，实时拥塞窗口大小是以字节为单位的。\n\n 刚开始发送数据时，先把**拥塞窗口（congestion window，cwnd）**设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍（指数增长）。比如，第一轮传一个，收到一个加一个，cwnd变为2MSS。第二轮传两个，收到两个加两个，cwnd变为4MSS。\n\n（2）拥塞避免\n\n当**拥塞窗口的大小达到慢开始门限(slow start threshold)**时，拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。\n\n无论是在**慢开始阶段**还是在**拥塞避免阶段**，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。\n\n（3）快重传\n\n快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的**重传计时器时间**到期。\n\n（4）快恢复\n\n当发送方连续收到三个重复确认时，就把**慢开始门限**和**拥塞窗口**减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。\n","categories":["计算机网络"]}]